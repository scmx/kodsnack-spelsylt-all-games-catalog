import { parse } from "node-html-parser";

import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { Game, Jam } from "../src/types";

async function main() {
  const jams = extractJamListFromReadme();

  for (const jam of jams.values()) {
    await fetchJamResults(jam);
    for (const game of jam.games) {
      await fetchGameInfo(game);
    }
  }
  writeFileSync(
    "./src/generated.json",
    JSON.stringify(
      { NOTE: "GENERATED by npm run generate", jams: Object.fromEntries(jams) },
      null,
      2,
    ),
  );

  console.log(jams);
}

function extractJamListFromReadme() {
  const markdown = readFileSync("./README.md", "utf-8") as string;
  const jams = new Map<string, Jam>();
  markdown.split("\n").forEach((line) => {
    let match = line.match(/\[([^\]]+)\]\[([^\]]+)\]/);
    if (match) {
      const title = match[1];
      const id = match[2];
      jams.set(id, { id, title, link: "", games: [] });
      return;
    }
    match = line.match(/\[([^\]]+)\]: ([^\s]+)/);
    if (match) {
      const id = match[1];
      const link = match[2];
      const jam = jams.get(id);
      jam!.link = link;
    }
  });
  return jams;
}

async function fetchJamResults(jam: Jam) {
  const doc = await fetchDocument(jam.link!);
  const results = doc.querySelectorAll(".game_rank");

  for (const result of results) {
    const thumb = result
      .querySelector(".game_thumb")!
      ?.getAttribute("data-lazy_src");
    const anchor = result.querySelector("h2 a")!;
    const title = anchor!.text.trim()!;
    const link = anchor!.getAttribute("href")!;
    const author = result.querySelector("h3 a")!.text.trim();
    const rank = parseInt(
      result.querySelector(".ordinal_rank")?.text.trim() ?? "0",
    );
    const h3s = result.querySelectorAll(".game_summary h3");
    const rankedText = [...h3s].at(-1)!.lastChild.text.trim();
    const matches = rankedText?.match(
      /^with (\d+) ratings \(Score\: ([\d.]+)\)$/,
    );
    const [ratings, score] = matches?.slice(1).map(Number) ?? [];
    const game: Game = {
      title,
      author,
      link,
      thumb,
      rank,
      ratings,
      score,
      platforms: {},
      priority: 0,
    };
    jam.games.push(game);
  }
  return results;
}

async function fetchGameInfo(game: Game) {
  const doc = await fetchDocument(game.link);
  const p = game.platforms;
  if (doc.querySelector(".game_frame iframe,.iframe_placeholder")) p.web = true;
  if (detectPlatform(doc, /mac\s?os/i, ".icon-apple")) p.mac = true;
  if (detectPlatform(doc, /windows/i, ".icon-windows8")) p.windows = true;
  if (detectPlatform(doc, /linux/i, ".icon-tux")) p.linux = true;
  if (detectPlatform(doc, /(?:\.love$|l[öÖ]ve|love2d)/i)) p.love2d = true;
}

function detectPlatform(doc: any, regex: RegExp, selector?: string) {
  if (selector && doc.querySelector(`.upload ${selector}`)) return true;
  if (uploadNameContains(doc, regex)) return true;
}

function uploadNameContains(doc: any, regex: RegExp) {
  return [...doc.querySelectorAll(".upload_name .name")].some((el) =>
    regex.test(el.getAttribute("title") ?? ""),
  );
}

async function fetchDocument(url: string) {
  const html = await withCache(url, async () => {
    const response = await fetch(url);
    return await response.text();
  });
  return parse(html);
}

async function withCache(url: string, fn: () => Promise<string>) {
  const cachePath = getCachePath(url);
  if (existsSync(cachePath)) {
    return readFileSync(cachePath, "utf-8");
  }
  const text = await fn();
  mkdirSync("./cache", { recursive: true });
  writeFileSync(cachePath, text);
  return text;
}

function getCachePath(url: string) {
  return `./cache/${url.replace(/[^a-zA-Z0-9]+/g, "-")}`;
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
